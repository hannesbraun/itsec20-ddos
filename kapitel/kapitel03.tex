\chapter{Schutzmaßnahmen}
\label{chap:kapitel3}
Ein vollständiger Schutz vor einem DDoS-Angriff ist nicht möglich. Jedoch gilt es die Hürde für einen Angreifer möglichst hoch zu setzen und einen Angriff so zu erschweren.

Grundsätzlich ist es zunächst wichtig die eigenen Systeme so abzusichern, dass sie möglichst erst gar nicht für einen Angriff verwendet werden können. Das ist zwar keine Maßnahme, welcher der Betroffene eines möglichen DDoS-Angriffs direkt selbst durchführen kann, jedoch ist es eigentlich eine der effektivsten Maßnahmen gegen einen Angriff.

Dazu ist es notwendig, dass besonders bei \ac{iot}-Geräten mehr auf die IT-Security geachtet wird. Einerseits sollten sich dabei die Nutzer dieser Geräte über die Risiken bewusst sein und als Gegenmaßnahme entsprechend ihre Geräte mit regelmäßigen Updates oder ähnlichem versorgen.
Aber auch die Entwickler von solchen Geräten sollten solche Probleme stets beachten und Produkte angemessen pflegen. Dazu gehört auch Dauer dieser Pflege. Diese ist ebenfalls sehr relevant, da IoT-Geräte auf Kundenseite oft einen wesentlich längeren Lebenszyklus haben als zum Beispiel ein Smartphone.

Wie sich in den letzten Jahren herausgestellt hat, sieht die Praxis leider oft anders aus. Gerade das Botnetz \glqq Mirai\grqq{} hat die Ausmaße vor einigen Jahren nochmals deutlich gemacht. Viel zu oft werden die Standard-Passwörter von IoT-Geräten nicht geändert.
Logischerweise ist es also auch auf der Seite der möglichen Betroffenen mehr als ratsam sich um einen Schutz gegen DDoS-Angriffe zu kümmern.

\section{Aufrüsten von Ressourcen}
\label{sec:k3rsc}
Im ersten Moment scheint es vielleicht sinnvoll die eigenen Ressourcen aufzurüsten. Selten ist das aber eine kluge Lösung. So schreibt auch Norbert Pohlmann \cite{Pohlmann2019}, dass der Kosten-Nutzen-Faktor dabei sehr gering ist. Während eine Verdopplung der eigenen Ressourcen (Bandbreite, CPU, RAM, ...) relativ teuer ist, ist der Aufwand seitens des Angreifers eher gering um auch das verstärkte System lahmzulegen.

\section{Blackhole-Routing}
Eine relativ einfache Abwehrmöglichkeit ist das sogenannte Blackhole-Routing. Dabei wird der eingehende Netzwerkverkehr (zum Beispiel über einen Reverse Proxy) gefiltert. \glqq Sauberer\grqq{} Netzwerkverkehr wird zum System weitergeleitet, bösartiger Netzwerkverkehr wird quasi ins Nichts (das Blackhole) geleitet. Neben der zusätzlichen Latenz, die hierbei hinzugefügt wird, ist vor allem die Unterscheidung von gutem und schlechtem Datenverkehr das Problem. Passieren hierbei Fehler, so besteht entweder die Gefahr das eigentliche Nutzer das System nicht nutzen können. Andererseits ist es aber genauso möglich, dass Angreifer trotzdem zum System weitergeleitet werden. Gerade wenn diese für den Angriff variable IP-Adressen benutzen, kann die Effektivität vom diesem Mechanismus durchaus eingeschränkt sein. \cite{CloudflareBlackhole}

Ebenfalls zielt diese Methode eher auf den Schutz der Server-Ressourcen selbst ab. Wird beim Angriff aber versucht bereits den Kommunikationskanal vollständig zu belegen, so ist diese Methode ebenfalls nicht ganz optimal. Sie funktioniert in dem Fall dann nur, wenn dem Proxy mehr Bandbreite zur Verfügung steht als dem eigentlichen System, für welches der Angriff bestimmt ist. An diesem Punkt ist allerdings auch wieder das Problem der Aufrüstung der Ressourcen zu berücksichtigen, welches im vorigen Abschnitt \ref{sec:k3rsc} erläutert wurde.

\section{SYN-Cookies}
Um speziell gegen SYN-Flooding-Angriffe vorzugehen gibt es SYN-Cookies. Mithilfe dieser lässt sich die Effektivität von eines SYN-Flooding-Angriffes sehr stark vermindern.

Hierfür macht man sich die vom Server mitgesendete Sequenznummer beim Drei-Wege-Handshake des TCP-Protokolls zu Nutze. Bei der Benutzung von SYN-Cookies wird diese folgendermaßen konstruiert: die ersten 5 Bits sind ein Zeitstempel mit einer Präzision von 64 Sekunden. Danach folgt die maximale Segmentgröße (Fenstergröße), codiert mit 3 Bits. Schließlich sind die weiteren 24 Bits das Ergebnis einer kryptografischen Hashfunktion. Als Eingabe erhält diese Client IP, Client Port, Server IP, Server Port und den bereits verwendeten Zeitstempel.

Auf diese Weise ist es nicht nötig, dass der Server den Status dieses Verbindungsaufbaus speichert. Stattdessen kann er sich die relevanten Informationen aus der Sequenznummer des ACKs rekonstruieren: die maximale Segmentgröße lässt sich ohne weiteres entnehmen, die Adressinformationen des Clients lassen sich aus dem Header rekonstruieren, die Adressinformationen des Servers sind diesem ohnehin bekannt. Mit dem aktuellen Zeitstempel werden diese Informationen dann erneut in die Hashfunktion gegeben. Stimmt das Ergebnis mit dem Ergebnis aus der Sequenznummer überein, so wird die Verbindung aufgebaut, andernfalls nicht. Beim zweiten Durchlauf der Hashfunktion ist es durchaus möglich, dass der Server im Fehlerfall weitere (etwas ältere) Zeitstempel ausprobiert. Dies hängt davon ab, ab wann ein Timeout für eine Verbindung greifen soll.

Der einzige Nachteil, der im ersten Moment auffällt, ist die verringerte maximale Fenstergröße (bedingt durch nur 3 Bits zur Speicherung dieses Werts). Allerdings werden SYN-Cookies erst dann eingesetzt, wenn Verbindungsanfragen normalerweise abgewiesen werden würden aufgrund von einem vollgelaufenen Speicher. In diesem Fall ist das somit eine Verbesserung: statt einer abgewiesenen Verbindung ist zumindest eine Verbindung mit eventuell verringerter Fenstergröße möglich. \cite{BernsteinSYN}

\subsection{Beispiel: Cloudflare}
Eine Abkürzung \ac{cd}, \ac{ci}. Ausgeschrieben \acl{cd}. Verweis zu einem File-Listing \ref{lst:crypter} oder einem Listing im Textfluss \ref{lst:Rggplot} und ein Inline-Listing \lstinline|print("Hello World")|.

\lstinputlisting[language=Java,caption={Ein Listing},label=lst:crypter]{\srcloc/Crypter.java}

\begin{lstlisting}[language=R,caption=Beispielaufruf ldply-Funktion in R, label=lst:Rggplot]
ggplot(data = data, mapping = aes(x=timestamp, y=score) + geom_line()
\end{lstlisting}
